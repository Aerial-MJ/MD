## Python 查看一个对象的所有属性

在Python中，有多种方法可以查看一个对象的所有属性和方法。以下是几种常用的方法：

### 使用 dir() 函数

**dir()** 是Python的内置函数，用于列出对象的所有属性和方法。它返回一个包含属性和方法名称的列表。对于类对象，*dir()* 函数将返回类的所有属性和方法，包括继承的属性和方法。例如：

```python
class Person:
   def __init__(self, name, age):
       self.name = name
       self.age = age
   def say_hello(self):
       print("Hello!")
# 创建一个Person对象
person = Person("Alice", 20)
# 使用dir()函数获取Person类的所有属性和方法
attributes = dir(Person)
print(attributes)
```

### 使用 vars() 函数

**vars()** 函数返回一个对象的属性和值的字典。对于类对象，**vars()** 函数将返回类的属性和对应的值的字典。例如：

```python
class Student:
   def __init__(self, name, sex, age):
       self.name = name
       self.sex = sex
       self.age = age
# 创建一个Student对象
jack = Student("Jack", "man", 10)
# 使用vars()函数获取Student类的所有属性和对应的值
attributes = vars(jack)
print(attributes)
```

输出结果将是一个包含属性和值的字典**dict**。

### 使用 __dict__ 属性

每个类对象都有一个名为 **\_\_dict\_\_**的属性，它是一个字典，包含了类的所有属性和对应的值。例如：

```python
class Person:
def __init__(self, name, age):
self.name = name
self.age = age

# 创建一个Person对象
person = Person("Alice", 20)

# 获取Person类的所有属性和对应的值
attributes = person.__dict__
print(attributes)
```

输出结果将是一个包含属性和值的字典**dict**。

### 使用 inspect 模块

**inspect** 模块提供了一些用于检查对象的函数。我们可以使用 **inspect.getmembers()** 函数来获取类的所有属性和方法。例如：

```python
import inspect

class Person:
	def __init__(self, name, age):
		self.name = name
		self.age = age

def say_hello(self):
	print("Hello!")

# 创建一个Person对象
person = Person("Alice", 20)

# 使用inspect模块的getmembers()函数获取Person类的所有属性和方法

attributes = inspect.getmembers(Person)
print(attributes)
```

输出结果将包含类的所有属性和方法，以及一些特殊的属性和方法

## 如何查看dict的key

在 Python 中，可以通过多种方法查看字典的所有键。以下是几种常用方法及示例。

### 使用 keys() 方法

**keys()** 方法返回一个包含字典所有键的视图对象，可通过 *list()* 转换为列表。

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}

keys = my_dict.keys()

print(keys) # 输出：dict_keys(['a', 'b', 'c'])

print(list(keys)) # 转换为列表：['a', 'b', 'c']
```

### 遍历字典

直接使用 **for** 循环遍历字典，默认会遍历所有键。

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}

for key in my_dict:
	print(key)

# 输出：
# a
# b
# c
```

要**获取Python字典中的键（key）和值（value）**，可以使用以下方法：

- 使用 `.items()` 方法获取所有键值对，例如：`for key, value in my_dict.items():`。
- 使用 `.keys()` 方法获取所有键，例如：`keys = my_dict.keys()`。
- 使用 `.values()` 方法获取所有值，例如：`values = my_dict.values()`。
- 通过列表推导式将键和值转换为列表，例如：`keys_list = list(my_dict.keys())` 和 `values_list = list(my_dict.values())`。 

## python 三元表达式

在Python中，三元表达式提供了一种简洁的方式来执行条件赋值。这种表达式通常用于在单行内根据条件判断来选择两个值中的一个。其基本语法是：

```python
result = value_if_true if condition else value_if_false
```

如果*condition*为真（True），则表达式返回*value_if_true*，否则返回*value_if_false*。

**示例**

假设我们需要根据两个数值来决定哪个更大，可以使用以下三元表达式：

```python
a, b = 5, 10

max_value = a if a > b else b
```

在这个例子中，如果*a*大于*b*，则*max_value*将被赋值为*a*，否则为*b*。

**嵌套三元表达式**

Python的三元表达式也支持嵌套，这意味着你可以在一个三元表达式的结果部分使用另一个三元表达式。例如：

```python
a, b, c = 5, 10, 15

max_value = a if a > b else c if c > b else b
```

这里，如果*a > b*成立，则返回*a*；否则，会检查*c > b*是否成立，如果成立，则返回*c*；如果都不成立，则返回*b*。

## python 中的推导式

好的，我帮你整理一个 **Python 推导式全家桶总结**，包括列表、字典、集合、元组，以及结合 `dict.items()` 和 `if-else` 的用法，并附上例子。为了方便理解，我会分模块列出。

------

###  列表推导式 (List Comprehension)

**基本语法：**

```python
[表达式 for 变量 in 可迭代对象 if 条件]
```

**例子：**

```python
# 生成0-9的平方
squares = [x**2 for x in range(10)]
# 生成偶数的平方
even_squares = [x**2 for x in range(10) if x % 2 == 0]
# 带if-else
labels = ["even" if x % 2 == 0 else "odd" for x in range(5)]
# 输出: ['even', 'odd', 'even', 'odd', 'even']
```

------

### 字典推导式 (Dict Comprehension)

**基本语法：**

```python
{key_expr: value_expr for key, value in 可迭代对象 if 条件}
```

**例子：**

```python
# 将列表中的数字映射为平方
nums = [1, 2, 3, 4]
squares_dict = {x: x**2 for x in nums}

# 带if过滤
even_squares_dict = {x: x**2 for x in nums if x % 2 == 0}

# 使用 dict.items()
grades = {"Alice": 85, "Bob": 72, "Charlie": 90}
passed = {k: ("Pass" if v >= 80 else "Fail") for k, v in grades.items()}
# 输出: {'Alice': 'Pass', 'Bob': 'Fail', 'Charlie': 'Pass'}
```

------

###  集合推导式 (Set Comprehension)

**基本语法：**

```python
{表达式 for 变量 in 可迭代对象 if 条件}
```

**例子：**

```python
# 集合中的平方
nums = [1, 2, 2, 3, 3]
squares_set = {x**2 for x in nums}  # 去重
# 带if-else
labels_set = {("even" if x % 2 == 0 else "odd") for x in range(5)}
# 输出: {'even', 'odd'}
```

------

###  元组推导式（实际上是生成器表达式）

元组没有直接的推导式，通常使用 **生成器表达式**，再转为元组：

```python
# 生成0-4的平方元组
squares_tuple = tuple(x**2 for x in range(5))

# 带if-else
labels_tuple = tuple("even" if x % 2 == 0 else "odd" for x in range(5))
```

> ⚠️ 注意：用 `()` 包括推导式本身创建的是生成器表达式，不会立即生成列表或元组，需要用 `tuple()` 转换。
>
> 仔细讲 **生成器表达式（Generator Expression）**，并跟列表推导式对比
>
> ------
>
> ### 什么是生成器表达式
>
> 生成器表达式是一种 **延迟生成数据** 的表达式，它不会一次性把所有结果存入内存，而是 **按需生成每一个值**。这和列表推导式不同，列表会一次性创建整个列表。
>
> **基本语法：**
>
> ```python
> (expression for 变量 in 可迭代对象 if 条件)
> ```
>
> > 注意：使用圆括号 `()` 包起来，而不是方括号 `[]`（方括号是列表推导式）。
>
> ------
>
> ### 列表推导式 vs 生成器表达式
>
> | 特性     | 列表推导式                   | 生成器表达式                   |
> | -------- | ---------------------------- | ------------------------------ |
> | 内存使用 | 一次性生成完整列表，消耗内存 | 按需生成元素，内存占用低       |
> | 语法     | `[x**2 for x in range(5)]`   | `(x**2 for x in range(5))`     |
> | 返回类型 | list                         | generator                      |
> | 遍历方式 | 可以直接索引                 | 只能迭代（for 循环、`next()`） |
>
> ------
>
> ### 生成器表达式示例
>
> ```python
> # 生成器表达式
> gen = (x**2 for x in range(5))
> 
> print(gen)  
> # 输出: <generator object <genexpr> at 0x...>
> 
> # 迭代生成值
> for val in gen:
>     print(val)
> # 输出:
> # 0
> # 1
> # 4
> # 9
> # 16
> 
> # 或使用 next()
> gen = (x**2 for x in range(3))
> print(next(gen))  # 0
> print(next(gen))  # 1
> print(next(gen))  # 4
> ```
>
> ------
>
> ### 转换为其他类型
>
> 你可以把生成器表达式转换成列表、元组或集合：
>
> ```python
> gen = (x**2 for x in range(5))
> 
> list_vals = list(gen)   # [0, 1, 4, 9, 16]
> tuple_vals = tuple(gen) # 注意：生成器已经被消耗完，如果重复使用需要重新生成
> ```
>
> ------
>
> ### 什么时候用生成器表达式
>
> - 数据量很大，不想一次性占用大量内存
> - 想按需生成值，例如逐行读取文件处理数据
> - 想节省计算资源，只计算实际需要的元素
>
> **例子：处理大文件行数**
>
> ```python
> # 不会一次性把整个文件读入内存
> line_lengths = (len(line) for line in open("big_file.txt"))
> 
> total_length = sum(line_lengths)
> ```
>
> ------
>
> 简单理解：
>
> - **列表推导式**：一次性生成所有结果，内存大但访问快
> - **生成器表达式**：按需生成结果，内存小，但只能顺序访问
>
> ------


------

### 推导式中的 if-else 小技巧

- **条件在表达式中 (三元表达式)**

  ```python
  ["even" if x % 2 == 0 else "odd" for x in range(5)]
  ```

- **条件在末尾 (过滤)**

  ```python
  [x**2 for x in range(10) if x % 2 == 0]
  ```

- **两者可以结合**

  ```python
  {x: ("big" if x > 5 else "small") for x in range(10) if x % 2 == 0}
  ```

>是的，条件（`if`）的确可以放在推导式的不同位置，这取决于你希望如何应用它。你可以将 `if` 放在 **前面**（用于过滤）或 **后面**（用于条件表达式）。我给你详细解释一下两种情况，并附上例子。
>
>------
>
>### 条件在前面（过滤）
>
>当 `if` 在前面时，它的作用是对可迭代对象进行过滤。只有满足条件的元素才会参与表达式的计算。
>
>**语法：**
>
>```python
>[表达式 for 变量 in 可迭代对象 if 条件]
>```
>
>**例子：**
>
>```python
># 生成0到9的偶数的平方
>even_squares = [x**2 for x in range(10) if x % 2 == 0]
># 输出: [0, 4, 16, 36, 64]
>```
>
>在这个例子中，`if x % 2 == 0` 会首先筛选出 0 到 9 之间的偶数，只有这些偶数的平方才会被计算出来。
>
>------
>
>### 条件在后面（三元表达式）
>
>当 `if` 在后面时，它是用于在表达式中根据条件做不同的计算，通常这种情况下会用 `else` 配合使用。
>
>**语法：**
>
>```python
>[表达式1 if 条件 else 表达式2 for 变量 in 可迭代对象]
>```
>
>**例子：**
>
>```python
># 判断数字是奇数还是偶数
>labels = ["even" if x % 2 == 0 else "odd" for x in range(5)]
># 输出: ['even', 'odd', 'even', 'odd', 'even']
>```
>
>在这个例子中，`"even" if x % 2 == 0 else "odd"` 是一个三元表达式，依据 `x` 是否为偶数来决定输出 `"even"` 或 `"odd"`。
>
>------
>
>### 条件在前面 + 后面条件表达式（混合）
>
>你还可以结合这两种方式：前面 `if` 进行过滤，后面 `if-else` 进行条件选择。
>
>**例子：**
>
>```python
># 判断偶数的平方和奇数的立方
>results = [x**2 if x % 2 == 0 else x**3 for x in range(10) if x > 4]
># 输出: [25, 36, 49, 64, 81, 100]
>```
>
>在这个例子中，首先通过 `if x > 4` 过滤出大于 4 的数字，然后对偶数执行平方运算，对奇数执行立方运算。
>
>------
>
>### 总结：
>
>- **`if` 在前面**：用于 **过滤**，只选择符合条件的元素。
>- **`if` 在后面**：用于 **条件表达式**，基于条件决定如何处理每个元素。
>- **两者结合使用**：你可以先过滤，再基于条件做不同的处理。
>

## 求和sum

###  sum() 用在集合（set）

集合中的元素必须是可加的（通常是数值类型），`sum()` 可以直接对集合求和：

```python
s = {1, 2, 3, 4}
total = sum(s)
print(total)  # 输出: 10
```

- ✅ 注意事项：
  - 集合是无序的，所以顺序不保证。
  - 元素必须是数值类型（int、float 等），不能是字符串、列表等。
  - 可以指定初始值：

```python
total = sum(s, 10)
print(total)  # 输出: 20 (10 + 1 + 2 + 3 + 4)
```

---

### sum() 用在字典（dict）

字典本身是可迭代对象，但迭代时默认迭代的是 **键**：

```python
d = {"a": 1, "b": 2, "c": 3}
sum(d)  # 其实是 sum(["a", "b", "c"]) 会报错
```

- ❌ 会报错，因为字符串类型无法直接相加。
- ✅ 正确方法是对 **字典的值** 或 **字典的键对应数值** 求和：

```python
# 对值求和
total_values = sum(d.values())
print(total_values)  # 输出: 6

# 对键对应数值求和（如果键是数值类型）
d2 = {1: 10, 2: 20, 3: 30}
total_keys = sum(d2)  # 等价于 sum(d2.keys())
print(total_keys)     # 输出: 6
```

- 也可以对 `dict.items()` 求和，但需要指定你要加哪一部分（key 或 value）：

```python
total_values = sum(v for k, v in d.items())
print(total_values)  # 输出: 6
```

### 总结

| 数据类型          | sum() 作用         | 注意事项                                             |
| ----------------- | ------------------ | ---------------------------------------------------- |
| list / tuple      | 对数值元素求和     | 元素必须可加                                         |
| set               | 对数值元素求和     | 元素必须可加，顺序不保证                             |
| dict              | 默认对 **键** 求和 | 键必须是数值类型，否则用 `d.values()` 或 `d.items()` |
| str / list / 其他 | 不可直接用         | 用 `''.join()` 或 `itertools.chain`                  |

>### sum() 对字符串/列表直接求和会报错
>
>```
># 字符串列表
>words = ["hello", "world"]
>
># 错误用法：
># total = sum(words)  
># TypeError: sum() can't sum strings [use ''.join(seq) instead]
>
># 列表的列表
>lists = [[1,2],[3,4]]
># total = sum(lists)  
># TypeError: can only sum numbers
>```
>
>原因：`sum()` 默认只处理数值类型，不能直接相加非数值对象（str、list）。
>
>------
>
>### 使用 ''.join() 拼接字符串
>
>```
>words = ["hello", "world"]
>sentence = ''.join(words)
>print(sentence)  # 输出: helloworld
>
>sentence2 = ' '.join(words)
>print(sentence2)  # 输出: hello world
>```
>
>- ✅ `''.join()` 会把可迭代对象中的 **字符串元素** 连接成一个字符串。
>- 注意：元素必须都是字符串类型。
>
>------
>
>### 使用 itertools.chain 合并列表
>
>```
>from itertools import chain
>
>lists = [[1, 2], [3, 4], [5]]
>merged = list(chain.from_iterable(lists))
>print(merged)  # 输出: [1, 2, 3, 4, 5]
>```
>
>- `chain.from_iterable()` 可以把可迭代对象的子迭代对象 **拆开合并成一个序列**。
>- 类似 `sum(lists, [])`，但 **效率更高**。
>
>```
># sum(lists, []) 也能实现合并，但对大列表效率低
>merged2 = sum(lists, [])
>print(merged2)  # [1,2,3,4,5]
>```

##  Python 中列表的追加、合并、扩展等操作

明白了，你是想系统学习 **Python 中列表的追加、合并、扩展等操作**，包括 `append()`、`extend()`、`+`、以及类似 `a += b` 的用法。我帮你整理一下：

------

### append() 方法

- **作用**：在列表末尾 **添加一个元素**（可以是任意对象，包括列表本身）。
- **语法**：

```python
list.append(object)
```

**示例：**

```python
a = [1, 2, 3]
a.append(4)
print(a)  # 输出: [1, 2, 3, 4]

# 添加一个列表作为单个元素
a.append([5, 6])
print(a)  # 输出: [1, 2, 3, 4, [5, 6]]
```

> ⚠️ 注意：`append()` 会把整个对象作为 **一个元素** 添加。

------

### extend() 方法

- **作用**：把一个可迭代对象（list、tuple、set 等）中的元素逐个添加到列表末尾。
- **语法**：

```python
list.extend(iterable)
```

**示例：**

```python
a = [1, 2, 3]
a.extend([4, 5])
print(a)  # 输出: [1, 2, 3, 4, 5]

# 可以扩展元组
a.extend((6, 7))
print(a)  # 输出: [1, 2, 3, 4, 5, 6, 7]
```

> ⚠️ 注意：`extend()` 会把可迭代对象 **拆开添加**，与 `append()` 不同。

------

### 列表相加 (`+`)

- **作用**：返回一个 **新列表**，是两个列表的合并。
- **语法**：

```python
c = a + b
```

**示例：**

```python
a = [1, 2]
b = [3, 4]
c = a + b
print(c)  # 输出: [1, 2, 3, 4]
print(a)  # 输出: [1, 2]  原列表不变
```

> ⚠️ `+` 会创建 **新列表**，不会修改原列表。

------

### 增量赋值 (`+=`)

- **作用**：把右边列表的元素添加到左边列表中，相当于 `extend()`，但 **修改原列表**。
- **语法**：

```python
a += b
```

**示例：**

```python
a = [1, 2]
b = [3, 4]
a += b
print(a)  # 输出: [1, 2, 3, 4]
```

- 与 `append()` 的区别：

```python
a = [1, 2]
a.append([3, 4])
print(a)  # [1, 2, [3, 4]]

a = [1, 2]
a += [3, 4]
print(a)  # [1, 2, 3, 4]
```

------

### 总结对比

| 方法/操作          | 作用         | 是否修改原列表 | 是否拆开迭代对象 |
| ------------------ | ------------ | -------------- | ---------------- |
| `append(x)`        | 添加单个元素 | ✅              | ❌                |
| `extend(iterable)` | 拆开元素添加 | ✅              | ✅                |
| `+`                | 返回新列表   | ❌              | ✅                |
| `+=`               | 拆开元素添加 | ✅              | ✅                |

## 获取维度

`.size()`、`.shape` 和 `len()` 是用于获取张量、数组或其他数据结构维度信息的方法。虽然它们都可以用来获取类似的内容，但它们的使用场景和返回类型略有不同。

### 1. .size()

- **适用对象**：PyTorch Tensor
- **功能**：返回张量的各个维度的大小（即每个维度的长度），通常是一个 `torch.Size` 对象（继承自元组）。
- **返回类型**：`torch.Size`（可以当作元组来使用）
- **常见用法**：获取张量的每一维的大小。

```python
import torch
x = torch.randn(2, 3, 4)
print(x.size())  # 输出：torch.Size([2, 3, 4])
print(x.size(0))  # 输出：2，第一维的大小
```

- `.size()` 可以直接用来获得某一维度的长度，也可以用来获取整体维度。

### 2. .shape

- **适用对象**：NumPy 数组和 PyTorch Tensor
- **功能**：和 `.size()` 类似，返回数据结构的形状，即各个维度的大小。
- **返回类型**：NumPy 数组和 PyTorch Tensor 中，`.shape` 返回的是元组。
- **常见用法**：获取数据的形状或维度大小。

```python
import torch
x = torch.randn(2, 3, 4)
print(x.shape)  # 输出：torch.Size([2, 3, 4])

import numpy as np
arr = np.random.randn(2, 3, 4)
print(arr.shape)  # 输出：(2, 3, 4)
```

- `.shape` 和 `.size()` 返回的效果非常相似，但 `.shape` 是 NumPy 和 PyTorch 都可以使用的方法，通常 `.size()` 是 PyTorch 特有的。

### 3. len()

- **适用对象**：Python 标准数据结构（如列表、元组、字符串）以及一维数组（对于 NumPy 或 PyTorch 张量）
- **功能**：返回对象的元素数量。如果是数组/张量，则返回第一个维度的大小。
- **返回类型**：整数
- **常见用法**：获取数据的第一个维度大小（如列表的长度或张量的第一维大小）。

```python
x = torch.randn(2, 3, 4)
print(len(x))  # 输出：2，只返回第一维的大小

arr = [1, 2, 3, 4, 5]
print(len(arr))  # 输出：5
```

- `len()` **只返回第一个维度的大小**，如果你有一个多维的张量或数组，`len()` 只会返回第一个维度的元素个数。

### 总结对比：

| 方法      | 适用对象                     | 返回类型             | 用途                               |
| --------- | ---------------------------- | -------------------- | ---------------------------------- |
| `.size()` | PyTorch Tensor               | `torch.Size`（元组） | 获取张量的所有维度大小             |
| `.shape`  | PyTorch Tensor, NumPy        | 元组                 | 获取数据的形状                     |
| `len()`   | 列表、PyTorch/NumPy 一维数组 | 整数                 | 获取数据的第一个维度大小（即长度） |

**例子：**

```python
import torch
x = torch.randn(3, 4, 5)

# 使用 .size()
print(x.size())  # 输出：torch.Size([3, 4, 5])
print(x.size(1))  # 输出：4，第二维的大小

# 使用 .shape
print(x.shape)  # 输出：torch.Size([3, 4, 5])

# 使用 len()
print(len(x))  # 输出：3，只返回第一维大小
```

**结论：**

- `len()` 只能获取第一个维度的大小。
- `.size()` 和 `.shape` 都可以获取所有维度的大小，但 `.size()` 是 PyTorch 特有的，`.shape` 是通用的，适用于 NumPy 和 PyTorch。
